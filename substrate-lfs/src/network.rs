use futures01::prelude::*;
use libp2p::{NetworkBehaviour, identity::PublicKey};
use libp2p::swarm::{NetworkBehaviourAction, NetworkBehaviourEventProcess};
use libp2p::kad::{Kademlia, KademliaConfig, KademliaEvent, Quorum, Record};
use libp2p::kad::record::{self, store::MemoryStore};
use std::collections::VecDeque;

/// General behaviour of the network. Combines all protocols together.
#[derive(NetworkBehaviour)]
#[behaviour(out_event = "BehaviourOut", poll_method = "poll")]
pub struct Behaviour<TSubstream> {
	/// Kademlia requests and answers.
	kademlia: Kademlia<TSubstream, MemoryStore>,

	/// Queue of events to produce for the outside.
	#[behaviour(ignore)]
	events: VecDeque<BehaviourOut>,
}

impl<TSubstream> Behaviour<TSubstream> {
	/// Builds a new `Behaviour`.
	pub fn new(local_public_key: PublicKey) -> Self {
		let local_id = local_public_key.into_peer_id();
		let store = MemoryStore::new(local_id.clone());

		let mut kad_config = KademliaConfig::default();
		kad_config.set_protocol_name(&b"/my-chain/kad/1"[..]);		// TODO: allow configuring the "my-chain" part

		Behaviour {
			kademlia: Kademlia::with_config(local_id.clone(), store, kad_config),
			events: VecDeque::new(),
		}
	}

	/// Start fetching a record from the DHT.
	///
	/// A corresponding `ValueFound` or `ValueNotFound` event will later be generated.
	pub fn get_value(&mut self, key: &record::Key) {
		self.kademlia.get_record(key, Quorum::One)
	}

	/// Start putting a record into the DHT. Other nodes can later fetch that value with
	/// `get_value`.
	///
	/// A corresponding `ValuePut` or `ValuePutFailed` event will later be generated.
	pub fn put_value(&mut self, key: record::Key, value: Vec<u8>) {
		self.kademlia.put_record(Record::new(key, value), Quorum::All);
	}

	/// Called by the implementation of `NetworkBehaviour` that is performed by the custom derive.
	fn poll<TEv>(&mut self) -> Async<NetworkBehaviourAction<TEv, BehaviourOut>> {
		if let Some(event) = self.events.pop_front() {
			return Async::Ready(NetworkBehaviourAction::GenerateEvent(event));
		}

		Async::NotReady
	}
}

/// Event generated by the `Behaviour`.
pub enum BehaviourOut {
	/// The DHT yeided results for the record request, grouped in (key, value) pairs.
	ValueFound(Vec<(record::Key, Vec<u8>)>),

	/// The record requested was not found in the DHT.
	ValueNotFound(record::Key),

	/// The record with a given key was successfully inserted into the DHT.
	ValuePut(record::Key),

	/// Inserting a value into the DHT failed.
	ValuePutFailed(record::Key),
}

impl<TSubstream> NetworkBehaviourEventProcess<KademliaEvent> for Behaviour<TSubstream> {
	fn inject_event(&mut self, ev: KademliaEvent) {
		match ev {
			KademliaEvent::UnroutablePeer { .. } => {}
			KademliaEvent::RoutingUpdated { .. } => {}
			KademliaEvent::GetRecordResult(res) => {
				self.events.push_back(match res {
					Ok(ok) => {
						let results = ok.records
							.into_iter()
							.map(|r| (r.key, r.value))
							.collect();

						BehaviourOut::ValueFound(results)
					}
					Err(e) => {
						BehaviourOut::ValueNotFound(e.into_key())
					}
				});
			}
			KademliaEvent::PutRecordResult(res) => {
				self.events.push_back(match res {
					Ok(ok) => BehaviourOut::ValuePut(ok.key),
					Err(e) => {
						BehaviourOut::ValuePutFailed(e.into_key())
					}
				});
			}
			KademliaEvent::RepublishRecordResult(res) => {
				match res {
					Ok(ok) => log::debug!(target: "sub-libp2p",
						"Libp2p => Record republished: {:?}",
						ok.key),
					Err(e) => log::warn!(target: "sub-libp2p",
						"Libp2p => Republishing of record {:?} failed with: {:?}",
						e.key(), e)
				}
			}
			KademliaEvent::Discovered { .. } => {}
			// We never start any other type of query.
			e => {
				log::warn!(target: "sub-libp2p", "Libp2p => Unhandled Kademlia event: {:?}", e)
			}
		}
	}
}
